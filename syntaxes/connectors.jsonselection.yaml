# use 'js-yaml' to convert to json
# npx js-yaml syntaxes/connectors.jsonselection.yaml >| syntaxes/connectors.jsonselection.json
name: "Apollo Connectors JSONSelection"
scopeName: "source.apollo.jsonselection"
patterns:
  - include: "#JSONSelection"
  - include: "source.graphql#graphql-skip-newlines"
repository:
  # JSONSelection        ::= PathSelection | NamedSelection*
  JSONSelection:
    name: "meta.JSONSelection"
    patterns:
      - include: "#PathSelection"
      - include: "#NamedSelection"
  # SubSelection         ::= "{" NamedSelection* "}"
  SubSelection:
    name: "meta.SubSelection"
    begin: "\\s*({)"
    beginCaptures:
      "1":
        name: "punctuation.SubSelection.open"
    end: "\\s*(})"
    endCaptures:
      "1":
        name: "punctuation.SubSelection.close"
    patterns:
      - include: "#NamedSelection"
  # NamedSelection       ::= NamedPathSelection | PathWithSubSelection | NamedFieldSelection | NamedGroupSelection
  NamedSelection:
    name: "meta.NamedSelection"
    patterns:
      #      - include: "#PathWithSubSelection"
      - include: "#NamedFieldSelection"
      - include: "#NamedPathSelection"
  #      - include: "#NamedGroupSelection"
  # NamedPathSelection   ::= Alias PathSelection
  NamedPathSelection:
    begin: "\\b([a-zA-Z][0-9a-zA-Z_]*)\\s*(:)"
    beginCaptures:
      "1":
        name: "string.unquoted.NamedPathSelection.alias"
      "2":
        name: "punctuation.colon.NamedPathSelection"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#PathSelection"
  # NamedFieldSelection  ::= Alias? Key SubSelection?
  NamedFieldSelection:
    begin: "\\b(?:([a-zA-Z][0-9a-zA-Z_]*)\\s*(:))?\\s*([a-zA-Z][0-9a-zA-Z_]*)\\b(?!\\s*:)"
    beginCaptures:
      "1":
        name: "string.unquoted.NamedFieldSelection.alias"
      "2":
        name: "punctuation.colon.NamedFieldSelection"
      "3":
        name: "variable.NamedFieldSelection.key"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#SubSelection"
  # NamedGroupSelection  ::= Alias SubSelection
  # Alias                ::= Key ":"
  # Path                 ::= VarPath | KeyPath | AtPath | ExprPath
  # PathSelection        ::= Path SubSelection?
  # PathWithSubSelection ::= Path SubSelection
  PathSelection:
    patterns:
      - include: "#PathWithOrWithoutSubSelection"
  PathWithSubSelection:
    patterns:
      - include: "#PathWithOrWithoutSubSelection"
  PathWithOrWithoutSubSelection:
    patterns:
      - include: "#ExprPath"
      - include: "#VarPath"
      - include: "#KeyPath"
      - include: "#AtPath"
  # VarPath              ::= "$" (NO_SPACE Identifier)? PathStep*
  VarPath:
    begin: "(\\$)([a-zA-Z][0-9a-zA-Z_]*)?(?!\\w)"
    beginCaptures:
      "1":
        name: "variable.VarPath.dollar"
      "2":
        name: "variable.VarPath.identifier"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#PathStep"
  # KeyPath              ::= Key PathStep+
  KeyPath:
    begin: '([a-zA-Z][0-9a-zA-Z_]*|"[^"]*"|''[^'']*'')'
    beginCaptures:
      "1":
        name: "variable.KeyPath.key.identifier"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#PathStep"
  # AtPath               ::= "@" PathStep*
  AtPath:
    begin: "(\\@)"
    beginCaptures:
      "1":
        name: "variable.AtPath.at"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#PathStep"
  # ExprPath             ::= "$(" LitExpr ")" PathStep*
  ExprPath:
    begin: "(\\$)"
    beginCaptures:
      "1":
        name: "variable.ExprPath.dollar"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - name: "meta.ExprPathArgs"
        begin: "([(])"
        beginCaptures:
          "1":
            name: "punctuation.brace.round.ExprPathArgs.open"
        end: "([)])"
        endCaptures:
          "1":
            name: "punctuation.brace.round.ExprPathArgs.close"
        patterns:
          - include: "#LitExpr"
      - include: "#PathStep"
  # PathStep             ::= "." Key | "->" Identifier MethodArgs?
  PathStep:
    begin: "(\\.)([a-zA-Z][0-9a-zA-Z_]*|\"[^\"]*\"|'[^']*')|(->)([a-zA-Z][0-9a-zA-Z_]*)"
    end: "(?=.)"
    applyEndPatternLast: 1
    beginCaptures:
      "1":
        name: "variable.PathStep.dot"
      "2":
        name: "variable.PathStep.key.identifier"
      "3":
        name: "punctuation.PathStep.arrow"
      "4":
        name: "variable.PathStep.identifier"
    patterns:
      - include: "#MethodArgs"
  # Key                  ::= Identifier | LitString
  # Identifier           ::= [a-zA-Z_] NO_SPACE [0-9a-zA-Z_]*
  # MethodArgs           ::= "(" (LitExpr ("," LitExpr)* ","?)? ")"
  MethodArgs:
    name: "meta.MethodArgs"
    begin: "([(])"
    beginCaptures:
      "1":
        name: "punctuation.brace.round.MethodArgs.open"
    end: "([)])"
    endCaptures:
      "1":
        name: "punctuation.brace.round.MethodArgs.close"
    patterns:
      - include: "#LitExpr"
      - match: ","
        name: "punctuation.comma.MethodArgs.separator"
  # LitExpr              ::= LitPrimitive | LitObject | LitArray | PathSelection
  LitExpr:
    patterns:
      - include: "#LitPrimitive"
      - include: "#LitObject"
      - include: "#LitArray"
      - include: "#PathSelection"
  # LitPrimitive         ::= LitString | LitNumber | "true" | "false" | "null"
  LitPrimitive:
    patterns:
      - include: "#LitString"
      - include: "#LitNumber"
      - match: "\\b(true|false|null)\\b"
        name: "constant.language.LitPrimitive"
  # LitString            ::= "'" ("\\'" | [^'])* "'" | '"' ('\\"' | [^"])* '"'
  LitString:
    name: "string.quoted.LitString"
    # prettier-ignore
    match: "(\")([^\"]*)(\")|(')([^']*)(')"
  # LitNumber            ::= "-"? ([0-9]+ ("." [0-9]*)? | "." [0-9]+)
  LitNumber:
    name: "constant.numeric.LitNumber"
    match: "\\b-?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b"
  # LitObject            ::= "{" (LitProperty ("," LitProperty)* ","?)? "}"
  LitObject:
    name: "meta.LitObject"
    begin: "\\s*({)"
    beginCaptures:
      "1":
        name: "punctuation.LitObject.open"
    end: "\\s*(})"
    endCaptures:
      "1":
        name: "punctuation.LitObject.close"
    patterns:
      - include: "#LitProperty"
      - match: ","
        name: "punctuation.comma.LitObject.separator"
  # LitProperty          ::= Key ":" LitExpr
  LitProperty:
    name: "meta.LitProperty"
    begin: "\\b([a-zA-Z][0-9a-zA-Z_]*)\\s*(:)\\s*"
    beginCaptures:
      "1":
        name: "variable.LitProperty.key"
      "2":
        name: "punctuation.colon.LitProperty"
    end: "(?=.)"
    applyEndPatternLast: 1
    patterns:
      - include: "#LitExpr"
  # LitArray             ::= "[" (LitExpr ("," LitExpr)* ","?)? "]"
  LitArray:
    name: "meta.LitArray"
    begin: "\\s*(\\[)"
    beginCaptures:
      "1":
        name: "punctuation.LitArray.open"
    end: "\\s*(\\])"
    endCaptures:
      "1":
        name: "punctuation.LitArray.close"
    patterns:
      - include: "#LitExpr"
      - match: ","
        name: "punctuation.comma.LitArray.separator"
  # NO_SPACE             ::= !SpacesOrComments
  # SpacesOrComments     ::= (Spaces | Comment)+
  # Spaces               ::= ("‚éµ" | "\t" | "\r" | "\n")+
  # Comment              ::= "#" [^\n]*

  # additional rules used for strings, e.g. in `POST: "/foo/bar/{$id}"`
  JSONSelectionString:
    contentName: string.quoted.JSONSelectionString
    begin: '(("))'
    beginCaptures:
      "1":
        name: "string.quoted.double.graphql"
      "2":
        name: "punctuation.definition.string.begin.graphql"
    end: '(("))'
    endCaptures:
      "1":
        name: "string.quoted.double.graphql"
      "2":
        name": "punctuation.definition.string.end.graphql"
    patterns:
      - name: "meta.JSONSelectionString.embedded"
        begin: "\\s*({)"
        beginCaptures:
          "1":
            name: "punctuation.JSONSelectionString.open"
        end: "\\s*(})"
        endCaptures:
          "1":
            name: "punctuation.JSONSelectionString.close"
        patterns:
          - include: "#PathSelection"
